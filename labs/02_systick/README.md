## Описание entry.S
[entry.S](entry.S) - определяет код, который будет исполняться до функции main. В этой лабораторной работе он довольно простой, но дальше он будет усложняться. Давайте разберём его step-by-step.

```assembly
.syntax unified

.section .text

.thumb_func
.global __reset_handler
__reset_handler:
    blx main
__halt:
	b __halt

.section .vector_table
.word __stack_start    // Initial SP
.word __reset_handler  // Reset Handler
```

- `.syntax unified` - директива, которая определяет тип синтаксиса файла. Для продвинутых, описание этой директивы подробнее можно посмотреть [здесь](https://sourceware.org/binutils/docs/as/ARM_002dInstruction_002dSet.html).
- `.section .text` - директива, которая определяет, что код ниже должен находиться в секции text. Как правило, в данной секции находится код программы.
- `.thumb_func` - директива, означает, что функция ниже написана в наборе инструкций типа Thumb. Для продвинутых, описание набора инструкций типа Thumb и ARM можно посмотреть [здесь](http://twins.ee.nctu.edu.tw/courses/ip_core_01/lab_hw_pdf/lab_1.pdf).
- `.global __reset_handler` - директива, означает, что символ(функция) `__reset_handler` должна быть видна из любой секции программы.
- `__reset_handler:` - определение символа `__reset_handler`.
- `blx main` - инструкция, которая перемещает текущее положение PC (Program Counter - адрес выполняемой команды) на символ `main`. Здесь и происходит вызов функции main.
- `b __halt` - инструкция, которая также перемещает текущее положение PC (Program Counter - адрес выполняемой команды) на символ `__halt`. Различие `B` и `BLX` можно посмотреть в [документации ARM](https://developer.arm.com/documentation/dui0489/h/arm-and-thumb-instructions/b--bl--bx--blx--and-bxj).
- `.section .vector_table` - определение секции vector_table. Данная секция содержит адрес начала стека `.word __stack_start`, адрес начального положения PC `.word __reset_handler` и адреса функций, который должны обрабатывать прерывания. Так как в нашей лабораторной нет прерываний, мы опустим их объявление. Символ `__reset_handler` определен выше, а символ `__stack_start` определен в линкер-скрипте.

## Описание линкер-скрипта
Как вы знаете, линкер объединяет входные файлы в один выходной файл. Выходной файл и каждый входной файл находятся в специальном формате данных, известном как ***формат объектного файла (.o)***. Каждый объектный файл имеет список секций (sections). Каждая секция в объектном файле имеет имя и размер. Некоторые секции имеют содержимое, например, секция .text хранит в себе код программы, секция .data хранит в себе данные программы. 

Каждая секция вывода имеет два адреса: VMA (Virtual Memory Adress) и LMA (Load Memory Adress). VMA - адрес, который секция будет иметь, во время исполнения выходного файла. LMA - адрес, по которому секция будет загружена. В большинстве случаев два адреса будут одинаковыми. Пример когда они могут отличаться, это когда раздел данных загружается во Flash-память, а затем копируется в SRAM-память при запуске программы. В этом случае адрес во Flash будет LMA, а адрес в SRAM будет VMA. Копирование это нужно, чтобы сохранить данные при выключении микроконтроллера. Когда микроконтроллер отключается от питания, все данные в SRAM стираются, а во Flash сохраняются.

Каждый объектный файл также имеет список символов, известный как таблица символов. Символы бывают определенными или неопределенными. У каждого символа есть имя, а у каждого определенного символа есть адрес. Если вы скомпилируете программу на C или C++ в объектный файл, то каждая функция, глобальная или статическая переменная получит определенный символ. А каждая неопределенная функция или глобальная переменная, на которые есть ссылка во входном файле, получат неопределенный символ. Задача линкера - собрать все символы со всех объектных файлов и определить все неопределенные символы. 

Давайте посмотрим на сгенерированные объектные файлы. Для этого выполните данные команды:
```
cd build
arm-none-eabi-objdump -t entry.o
```

Вы должны увидеть это:
```
SYMBOL TABLE:
00000000 l    d  .text  00000000 .text
00000000 l    d  .data  00000000 .data
00000000 l    d  .bss   00000000 .bss
00000004 l       .text  00000000 __halt
00000000 l    d  .vector_table  00000000 .vector_table
00000000 l    d  .ARM.attributes        00000000 .ARM.attributes
00000000 g     F .text  00000000 __reset_handler
00000000         *UND*  00000000 main
00000000         *UND*  00000000 __stack_start
```
Первый столбец - это значение символа. Оно у всех ноль, кроме символа `__halt`, потому что он расположен сразу после символа `__reset_handler:`, который из-за команды `blx main` имеет размер 4 байта. Второй столбец - флаги символов. Флаг l означает, что символ локальный и виден только из данного файла, g означает, что символ глобальный. Глобальным является только символ `__reset_handler`, потому что перед ним явно написана директива `.global` в файле [entry.S](entry.S). F означает, что символ является именем функции. d означает, что символ создан для отладки программы (debug). Третий столбец определяет секцию, в которой находится символ. `*UND*` означает, что секция не определена. Четвертый столбец - размер символа TODO ПОЧЕМУ РАЗМЕР `__reset_handle` РАВЕН 0. Последний столбец - это имя символа.

Линкер-скрипт управляет работой линкера. [entry.lds](entry.lds) - определяет как в конечной программе должны располагаться секции и определяет каким образом должна быть разделена память. Давайте рассмотрим этот скрипт step-by-step.

```assembly
ENTRY(__reset_handler);

FLASH_PADDR = 0x08000000;
FLASH_SIZE  = 0x00010000;
SRAM_PADDR  = 0x20000000;
SRAM_SIZE   = 0x00002000;

SECTIONS
{
    . = 0x00000000;

    .text : AT(ADDR(.text) + FLASH_PADDR)
    {
        KEEP(*(.vector_table));
        *(.text)
        *(.rodata)
    }

    __stack_start = SRAM_PADDR + SRAM_SIZE;
}
```

- `ENTRY(__reset_handler);` - определяет символ, с которого мы должны начать выполнение программы.
- FLASH_PADDR = 0x08000000;`` - константа. Адрес начала Flash-памяти. Значение этой константы должно совпадать с разделением памяти в STM32F051, которое можно посмотреть в [stm32f0xx_rm](docs/stm32f0xx_rm.pdf) на странице 45.
- `FLASH_SIZE  = 0x00010000;` - константа. Размер Flash-памяти. Для каждой программы размер Flash-памяти должен определяться отдельно.
- `SRAM_PADDR  = 0x20000000;` - константа. Адрес начала SRAM-памяти. Значение этой константы должно совпадать с разделением памяти в STM32F051.
- `SRAM_SIZE   = 0x00002000;` - константа. Размер SRAM-памяти. Для каждой программы размер SRAM-памяти должен определяться отдельно.
- `SECTIONS` - означает, что ниже будут описаны секции, которые должны быть в конечной программе.
- `. = 0x00000000;` - определение счетчик местоположения (location counte). Определяет на каком адресе мы сейчас находимся. Относительно него будут далее определяться адреса секций.
- `.text : AT(ADDR(.text) + FLASH_PADDR)` - означает, что мы определяем секцию .text, LMA которой равен ADDR(.text) + FLASH_PADDR = VMA адрес секции .text + 0x08000000. VMA адрес данной секции будет равен 0x00000000.
- `KEEP(*(.vector_table));` - далее в фигурных скобках перечисляется всё, что должно входить в секцию .text. `*(.vector_table)` означает, что в секцию .text должны входить все секции .vector_table входных файлов. KEEP() нужен для того, чтобы линкер-скрипт не оптимизировал эти секции и не удалил их.
- `*(.text)` - означает, что в секцию .text выходного файлы должны входить все секции .text входных файлов.
- `*(.rodata)` - аналогично.
- `__stack_start = SRAM_PADDR + SRAM_SIZE;` - определяет адрес символа адреса начала стека `__stack_start`.

Давайте посмотрим на результат работы линкер-скрипта. Для этого в папке build нужно выполнить следующую команду:
```
arm-none-eabi-objdump -t blinkled.elf
```
В ответе на команду нас не интересуют все строки, рассмотрим только следующие:
```
00000000 l    d  .text  00000000 .text
00000008 g     F .text  00000000 __reset_handler
0000000c l       .text  00000000 __halt
20002000 g       *ABS*  00000000 __stack_start
```
Согласно линкер-скрипту, по адресу 00000000 находится секция .text, в начале которой расположен `.vector_table`. А `.vector_table` в свою очередь состоит из `.word __stack_start` и `.word __reset_handler`. Тогда, по адресу 00000000 находится начальное положение стека, а по адресу 00000004 находится адрес функции `__reset_handler  `, в этом можно убедиться, если выполнть команду:
```
arm-none-eabi-objdump -t blinkled.elf
```
Ответом на команду будет дизассемблированный исполняемый файл:
```
00000000 <__reset_handler-0x8>:
   0:   20002000        .word   0x20002000
   4:   00000009        .word   0x00000009

00000008 <__reset_handler>:
   8:   f000 f88c       bl      124 <main>

0000000c <__halt>:
   c:   e7fe            b.n     c <__halt>
        ...
```
Видно, что значение `__stack_start` равно 0x20002000, что совпадает с выводом таблицы символов.

## Задачи к лабораторной №2
- [ ] Отрефакторить код:
	- [ ] В любой момент времени должно быть понятно, в какой бит какого регистра осуществляется запись.
	- [ ] Реализовать дефайны для всех бит регистров (см. документацию на микроконтроллер).
	- [ ] Реализовать макросы для записи значений в регистры.
	- [ ] Выделить заголовочные файлы, где это осмысленно.
- [ ] Устранить ошибки записи в неинициализированные глобальные переменные.
- [ ] Устранить гонку при работе с диодами.
- [ ] Перенести на прерывания:
	- [ ] Пример на скорость реакции
	- [ ] Игру в "пальчики"
